var searchIndex = {};
searchIndex["alsa"] = {"doc":"This ALSA API wrapper/binding is WIP - the ALSA API is huge, and new\nfunctions and structs might be added as requested. Enjoy!","items":[[3,"Error","alsa","Most ALSA functions can return a negative error code.\nIf so, then that error code is wrapped into this `Error` struct.\nAn Error is also returned in case ALSA returns a string that\ncannot be translated into Rust&#39;s UTF-8 strings.",null,null],[3,"Ctl","","[snd_ctl_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[3,"Output","","[snd_output_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___output.html) wrapper",null,null],[4,"Direction","","Replaces constants ending with PLAYBACK/CAPTURE as well as\nINPUT/OUTPUT",null,null],[13,"Playback","","",0,null],[13,"Capture","","",0,null],[4,"ValueOr","","Used to restrict hw parameters. In case the submitted\nvalue is unavailable, in which direction should one search\nfor available values?",null,null],[13,"Less","","The value set is the submitted value, or less",1,null],[13,"Nearest","","The value set is the submitted value, or the nearest",1,null],[13,"Greater","","The value set is the submitted value, or greater",1,null],[4,"Round","","Rounding mode (used in some mixer related calls)",null,null],[13,"Floor","","Round down (towards negative infinity)",2,null],[13,"Ceil","","Rount up (towards positive infinity)",2,null],[11,"fmt","","",3,null],[11,"new","","",3,{"inputs":[{"name":"option"},{"name":"c_int"}],"output":{"name":"error"}}],[11,"code","","",3,null],[11,"description","","",3,null],[11,"fmt","","",3,null],[0,"card","","Sound card enumeration",null,null],[3,"Card","alsa::card","An ALSA sound card, uniquely identified by its index.",null,null],[3,"Iter","","Iterate over existing sound cards.",null,null],[11,"cmp","","",4,null],[11,"partial_cmp","","",4,null],[11,"lt","","",4,null],[11,"le","","",4,null],[11,"gt","","",4,null],[11,"ge","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"new","","",5,{"inputs":[],"output":{"name":"iter"}}],[11,"next","","",5,null],[11,"new","","",4,{"inputs":[{"name":"c_int"}],"output":{"name":"card"}}],[11,"from_str","","",4,{"inputs":[{"name":"cstr"}],"output":{"name":"result"}}],[11,"get_name","","",4,null],[11,"get_longname","","",4,null],[11,"get_index","","",4,null],[11,"open","alsa","Open does not support async mode (it&#39;s not very Rustic anyway)",6,{"inputs":[{"name":"cstr"},{"name":"bool"}],"output":{"name":"result"}}],[11,"from_card","","",6,{"inputs":[{"name":"card"},{"name":"bool"}],"output":{"name":"result"}}],[11,"card_info","","",6,null],[11,"wait","","",6,null],[11,"drop","","",6,null],[11,"count","","",6,null],[11,"fill","","",6,null],[11,"revents","","",6,null],[0,"ctl","","Control device API",null,null],[3,"Ctl","alsa::ctl","[snd_ctl_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[3,"CardInfo","","[snd_ctl_card_info_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[3,"ElemId","","[snd_ctl_elem_id_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[3,"ElemValue","","[snd_ctl_elem_value_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[3,"ElemInfo","","[snd_ctl_elem_info_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[4,"ElemIface","","[SND_CTL_ELEM_IFACE_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) constants",null,null],[13,"Card","","",7,null],[13,"Hwdep","","",7,null],[13,"Mixer","","",7,null],[13,"PCM","","",7,null],[13,"Rawmidi","","",7,null],[13,"Timer","","",7,null],[13,"Sequencer","","",7,null],[4,"ElemType","","[SND_CTL_ELEM_TYPE_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) constants",null,null],[13,"None","","",8,null],[13,"Boolean","","",8,null],[13,"Integer","","",8,null],[13,"Enumerated","","",8,null],[13,"Bytes","","",8,null],[13,"IEC958","","",8,null],[13,"Integer64","","",8,null],[0,"hctl","alsa","HCtl API - for mixer control and jack detection",null,null],[3,"HCtl","alsa::hctl","[snd_hctl_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___h_control.html) wrapper",null,null],[3,"ElemIter","","Iterates over elements for a `HCtl`",null,null],[3,"Elem","","[snd_hctl_elem_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___h_control.html) wrapper",null,null],[11,"drop","","",9,null],[11,"open","","Open does not support async mode (it&#39;s not very Rustic anyway)\nNote: You probably want to call `load` afterwards.",9,{"inputs":[{"name":"cstr"},{"name":"bool"}],"output":{"name":"result"}}],[11,"load","","",9,null],[11,"elem_iter","","",9,null],[11,"find_elem","","",9,null],[11,"wait","","",9,null],[11,"count","","",9,null],[11,"fill","","",9,null],[11,"revents","","",9,null],[11,"next","","",10,null],[11,"get_id","","",11,null],[11,"info","","",11,null],[11,"read","","",11,null],[11,"write","","",11,null],[0,"pcm","alsa","Audio playback and capture",null,null],[3,"Chmap","alsa::pcm","[snd_pcm_chmap_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) wrapper",null,null],[3,"ChmapsQuery","","Iterator over available channel maps - see [snd_pcm_chmap_query_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html)",null,null],[3,"Info","","",null,null],[3,"PCM","","[snd_pcm_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) wrapper - start here for audio playback and recording",null,null],[3,"IO","","Sample format dependent struct for reading from and writing data to a `PCM`.\nAlso implements `std::io::Read` and `std::io::Write`.",null,null],[3,"HwParams","","[snd_pcm_hw_params_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m___h_w___params.html) wrapper",null,null],[3,"SwParams","","[snd_pcm_sw_params_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m___s_w___params.html) wrapper",null,null],[3,"Status","","[snd_pcm_status_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m___status.html) wrapper",null,null],[4,"ChmapPosition","","[SND_CHMAP_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) constants",null,null],[13,"Unknown","","",12,null],[13,"NA","","",12,null],[13,"Mono","","",12,null],[13,"FL","","",12,null],[13,"FR","","",12,null],[13,"RL","","",12,null],[13,"SR","","",12,null],[13,"RC","","",12,null],[13,"FLC","","",12,null],[13,"FRC","","",12,null],[13,"RLC","","",12,null],[13,"RRC","","",12,null],[13,"FLW","","",12,null],[13,"FRW","","",12,null],[13,"FLH","","",12,null],[13,"FCH","","",12,null],[13,"FRH","","",12,null],[13,"TC","","",12,null],[13,"TFL","","",12,null],[13,"TFR","","",12,null],[13,"TFC","","",12,null],[13,"TRL","","",12,null],[13,"TRR","","",12,null],[13,"TRC","","",12,null],[13,"TFLC","","",12,null],[13,"TFRC","","",12,null],[13,"TSL","","",12,null],[13,"TSR","","",12,null],[13,"LLFE","","",12,null],[13,"RLFE","","",12,null],[13,"BC","","",12,null],[13,"BLC","","",12,null],[13,"BRC","","",12,null],[4,"ChmapType","","[SND_CHMAP_TYPE_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) constants",null,null],[13,"None","","",13,null],[13,"Fixed","","",13,null],[13,"Var","","",13,null],[13,"Paired","","",13,null],[4,"State","","[SND_PCM_STATE_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) constants",null,null],[13,"Open","","",14,null],[13,"Setup","","",14,null],[13,"Prepared","","",14,null],[13,"Running","","",14,null],[13,"XRun","","",14,null],[13,"Draining","","",14,null],[13,"Paused","","",14,null],[13,"Suspended","","",14,null],[13,"Disconnected","","",14,null],[4,"Format","","[SND_PCM_FORMAT_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) constants",null,null],[13,"Unknown","","",15,null],[13,"S8","","",15,null],[13,"U8","","",15,null],[13,"S16LE","","",15,null],[13,"S16BE","","",15,null],[13,"U16LE","","",15,null],[13,"U16BE","","",15,null],[13,"S24LE","","",15,null],[13,"S24BE","","",15,null],[13,"U24LE","","",15,null],[13,"U24BE","","",15,null],[13,"S32LE","","",15,null],[13,"S32BE","","",15,null],[13,"U32LE","","",15,null],[13,"U32BE","","",15,null],[13,"FloatLE","","",15,null],[13,"FloatBE","","",15,null],[13,"Float64LE","","",15,null],[13,"Float64BE","","",15,null],[13,"IEC958SubframeLE","","",15,null],[13,"IEC958SubframeBE","","",15,null],[13,"MuLaw","","",15,null],[13,"ALaw","","",15,null],[13,"ImaAdPCM","","",15,null],[13,"MPEG","","",15,null],[13,"GSM","","",15,null],[13,"Special","","",15,null],[13,"S243LE","","",15,null],[13,"S243BE","","",15,null],[13,"U243LE","","",15,null],[13,"U243BE","","",15,null],[13,"S203LE","","",15,null],[13,"S203BE","","",15,null],[13,"U203LE","","",15,null],[13,"U203BE","","",15,null],[13,"S183LE","","",15,null],[13,"S183BE","","",15,null],[13,"U183LE","","",15,null],[13,"U183BE","","",15,null],[13,"G72324","","",15,null],[13,"G723241B","","",15,null],[13,"G72340","","",15,null],[13,"G723401B","","",15,null],[13,"DSDU8","","",15,null],[13,"DSDU16LE","","",15,null],[4,"Access","","[SND_PCM_ACCESS_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) constants",null,null],[13,"MMapInterleaved","","",16,null],[13,"MMapNonInterleaved","","",16,null],[13,"MMapComplex","","",16,null],[13,"RWInterleaved","","",16,null],[13,"RWNonInterleaved","","",16,null],[6,"Frames","","[snd_pcm_sframes_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html)",null,null],[11,"new","","",17,{"inputs":[],"output":{"name":"result"}}],[11,"get_card","","",17,null],[11,"get_device","","",17,null],[11,"get_subdevice","","",17,null],[11,"get_id","","",17,null],[11,"get_name","","",17,null],[11,"get_subdevice_name","","",17,null],[11,"drop","","",17,null],[11,"open","","",18,{"inputs":[{"name":"cstr"},{"name":"direction"},{"name":"bool"}],"output":{"name":"result"}}],[11,"start","","",18,null],[11,"drop","","",18,null],[11,"pause","","",18,null],[11,"resume","","",18,null],[11,"drain","","",18,null],[11,"prepare","","",18,null],[11,"reset","","",18,null],[11,"recover","","",18,null],[11,"wait","","",18,null],[11,"state","","",18,null],[11,"bytes_to_frames","","",18,null],[11,"frames_to_bytes","","",18,null],[11,"avail_update","","",18,null],[11,"avail","","",18,null],[11,"avail_delay","","",18,null],[11,"status","","",18,null],[11,"io_i8","","",18,null],[11,"io_u8","","",18,null],[11,"io_i16","","",18,null],[11,"io_u16","","",18,null],[11,"io_i32","","",18,null],[11,"io_u32","","",18,null],[11,"io_f32","","",18,null],[11,"io_f64","","",18,null],[11,"io","","",18,null],[11,"hw_params","","Sets hw parameters. Note: No IO object can exist for this PCM\nwhen hw parameters are set.",18,null],[11,"hw_params_current","","",18,null],[11,"sw_params","","",18,null],[11,"sw_params_current","","",18,null],[11,"info","","",18,null],[11,"dump","","",18,null],[11,"dump_hw_setup","","",18,null],[11,"dump_sw_setup","","",18,null],[11,"query_chmaps","","",18,null],[11,"set_chmap","","",18,null],[11,"get_chmap","","",18,null],[11,"drop","","",18,null],[11,"count","","",18,null],[11,"fill","","",18,null],[11,"revents","","",18,null],[11,"drop","","",19,null],[11,"writei","","On success, returns number of *frames* written.\n(Multiply with number of channels to get number of items in buf successfully written.)",19,null],[11,"readi","","On success, returns number of *frames* read.\n(Multiply with number of channels to get number of items in buf successfully read.)",19,null],[11,"mmap","","Wrapper around snd_pcm_mmap_begin and snd_pcm_mmap_commit.",19,null],[11,"read","","",19,null],[11,"write","","",19,null],[11,"flush","","",19,null],[11,"hash","","",14,null],[11,"cmp","","",14,null],[11,"partial_cmp","","",14,null],[11,"eq","","",14,null],[11,"clone","","",14,null],[11,"fmt","","",14,null],[11,"all","","Returns a slice of all possible values; useful for iteration",14,null],[11,"hash","","",15,null],[11,"cmp","","",15,null],[11,"partial_cmp","","",15,null],[11,"eq","","",15,null],[11,"clone","","",15,null],[11,"fmt","","",15,null],[11,"all","","Returns a slice of all possible values; useful for iteration",15,null],[11,"s16","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"u16","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"s24","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"u24","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"s32","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"u32","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"float","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"float64","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"iec958_subframe","","",15,{"inputs":[],"output":{"name":"format"}}],[11,"hash","","",16,null],[11,"cmp","","",16,null],[11,"partial_cmp","","",16,null],[11,"eq","","",16,null],[11,"clone","","",16,null],[11,"fmt","","",16,null],[11,"all","","Returns a slice of all possible values; useful for iteration",16,null],[11,"drop","","",20,null],[11,"any","","",20,{"inputs":[{"name":"pcm"}],"output":{"name":"result"}}],[11,"get_rate_resample","","",20,null],[11,"set_rate_resample","","",20,null],[11,"set_channels_near","","",20,null],[11,"set_channels","","",20,null],[11,"get_channels","","",20,null],[11,"set_rate_near","","",20,null],[11,"set_rate","","",20,null],[11,"get_rate","","",20,null],[11,"set_format","","",20,null],[11,"get_format","","",20,null],[11,"set_access","","",20,null],[11,"get_access","","",20,null],[11,"set_period_size_near","","",20,null],[11,"set_period_size","","",20,null],[11,"get_period_size","","",20,null],[11,"set_periods","","",20,null],[11,"get_periods","","",20,null],[11,"set_buffer_size_near","","",20,null],[11,"set_buffer_size","","",20,null],[11,"get_buffer_size","","",20,null],[11,"dump","","",20,null],[11,"copy_from","","",20,null],[11,"clone","","",20,null],[11,"fmt","","",20,null],[11,"drop","","",21,null],[11,"set_avail_min","","",21,null],[11,"get_avail_min","","",21,null],[11,"set_start_threshold","","",21,null],[11,"get_start_threshold","","",21,null],[11,"set_stop_threshold","","",21,null],[11,"get_stop_threshold","","",21,null],[11,"set_tstamp_mode","","",21,null],[11,"get_tstamp_mode","","",21,null],[11,"dump","","",21,null],[11,"fmt","","",21,null],[11,"get_htstamp","","",22,null],[11,"get_trigger_htstamp","","",22,null],[11,"get_audio_htstamp","","",22,null],[11,"get_state","","",22,null],[11,"get_avail","","",22,null],[11,"get_delay","","",22,null],[11,"get_avail_max","","",22,null],[11,"get_overrange","","",22,null],[11,"dump","","",22,null],[0,"rawmidi","alsa","MIDI devices I/O and enumeration",null,null],[3,"Iter","alsa::rawmidi","Iterator over [Rawmidi](http://www.alsa-project.org/alsa-doc/alsa-lib/group___raw_midi.html) devices and subdevices",null,null],[3,"Info","","[snd_rawmidi_info_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___raw_midi.html) wrapper",null,null],[3,"Rawmidi","","[snd_rawmidi_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___raw_midi.html) wrapper",null,null],[3,"IO","","Implements `std::io::Read` and `std::io::Write` for `Rawmidi`",null,null],[11,"drop","","",23,null],[11,"get_device","","",23,null],[11,"get_subdevice","","",23,null],[11,"get_stream","","",23,null],[11,"get_subdevice_name","","",23,null],[11,"get_id","","",23,null],[11,"new","","",24,{"inputs":[{"name":"ctl"}],"output":{"name":"iter"}}],[11,"next","","",24,null],[11,"drop","","",25,null],[11,"open","","",25,{"inputs":[{"name":"cstr"},{"name":"direction"},{"name":"bool"}],"output":{"name":"result"}}],[11,"info","","",25,null],[11,"drop","","",25,null],[11,"drain","","",25,null],[11,"name","","",25,null],[11,"io","","",25,null],[11,"count","","",25,null],[11,"fill","","",25,null],[11,"revents","","",25,null],[11,"read","","",26,null],[11,"write","","",26,null],[11,"flush","","",26,null],[0,"device_name","alsa","Enumerate devices in the alsa library configuration",null,null],[3,"HintIter","alsa::device_name","[snd_device_name_hint](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[3,"Hint","","[snd_device_name_get_hint](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper",null,null],[12,"name","","",27,null],[12,"desc","","",27,null],[12,"direction","","",27,null],[11,"drop","","",28,null],[11,"new","","typical interfaces are: &quot;pcm&quot;, &quot;ctl&quot;, &quot;rawmidi&quot;, &quot;timer&quot;, &quot;seq&quot; and &quot;hwdep&quot;.",28,{"inputs":[{"name":"option"},{"name":"cstr"}],"output":{"name":"result"}}],[11,"next","","",28,null],[11,"clone","","",27,null],[11,"fmt","","",27,null],[0,"poll","alsa","Tiny poll ffi",null,null],[3,"PollFlags","alsa::poll","",null,null],[5,"poll","","Wrapper around the libc poll call.",null,null],[5,"poll_all","","Builds a pollfd array, polls it, and returns the poll descriptors which have non-zero revents.",null,null],[17,"POLLIN","","",null,null],[17,"POLLPRI","","",null,null],[17,"POLLOUT","","",null,null],[17,"POLLERR","","",null,null],[17,"POLLHUP","","",null,null],[17,"POLLNVAL","","",null,null],[8,"PollDescriptors","","",null,null],[10,"count","","",29,null],[10,"fill","","",29,null],[10,"revents","","",29,null],[11,"get","","Wrapper around count and fill - returns an array of pollfds",29,null],[11,"hash","","",30,null],[11,"cmp","","",30,null],[11,"partial_cmp","","",30,null],[11,"lt","","",30,null],[11,"le","","",30,null],[11,"gt","","",30,null],[11,"ge","","",30,null],[11,"clone","","",30,null],[11,"eq","","",30,null],[11,"ne","","",30,null],[11,"fmt","","",30,null],[11,"empty","","Returns an empty set of flags.",30,{"inputs":[],"output":{"name":"pollflags"}}],[11,"all","","Returns the set containing all flags.",30,{"inputs":[],"output":{"name":"pollflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",30,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",30,{"inputs":[{"name":"c_short"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",30,{"inputs":[{"name":"c_short"}],"output":{"name":"pollflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",30,null],[11,"is_all","","Returns `true` if all flags are currently set.",30,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",30,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",30,null],[11,"insert","","Inserts the specified flags in-place.",30,null],[11,"remove","","Removes the specified flags in-place.",30,null],[11,"toggle","","Toggles the specified flags in-place.",30,null],[11,"bitor","","Returns the union of the two sets of flags.",30,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",30,null],[11,"bitand","","Returns the intersection between the two sets of flags.",30,null],[11,"sub","","Returns the set difference of the two sets of flags.",30,null],[11,"not","","Returns the complement of this set of flags.",30,null],[11,"from_iter","","",30,{"inputs":[{"name":"t"}],"output":{"name":"pollflags"}}],[0,"mixer","alsa","Mixer API - Simple Mixer API for mixer control",null,null],[3,"Mixer","alsa::mixer","wraps [snd_mixer_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___mixer.html)",null,null],[3,"MilliBel","","Wrapper for a mB (millibel) value.",null,null],[12,"0","","",31,null],[3,"Elem","","Wraps [snd_mixer_elem_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___mixer.html)",null,null],[3,"Iter","","Iterator for all elements of mixer",null,null],[3,"SelemId","","Wrapper for [snd_mixer_selem_id_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___simple_mixer.html)\nNo allocation (uses fixed array)",null,null],[3,"Selem","","Wraps an Elem as a Selem",null,null],[3,"IterEnum","","",null,null],[4,"SelemChannelId","","Wrapper for [SND_MIXER_SCHN_*](http://www.alsa-project.org/alsa-doc/alsa-lib/group___simple_mixer.html) constants",null,null],[13,"Unknown","","",32,null],[13,"FrontLeft","","",32,null],[13,"FrontRight","","",32,null],[13,"RearLeft","","",32,null],[13,"RearRight","","",32,null],[13,"FrontCenter","","",32,null],[13,"Woofer","","",32,null],[13,"SideLeft","","",32,null],[13,"SideRight","","",32,null],[13,"RearCenter","","",32,null],[13,"Last","","",32,null],[11,"fmt","","",33,null],[11,"new","","Opens a mixer and attaches it to a card identified by its name (like hw:0) and loads the\nmixer after registering a Selem.",33,{"inputs":[{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"find_selem","","Creates a Selem by looking for a specific selem by name given a mixer (of a card)",33,null],[11,"open","","",33,{"inputs":[{"name":"bool"}],"output":{"name":"result"}}],[11,"attach","","",33,null],[11,"load","","",33,null],[11,"iter","","",33,null],[11,"wait","","",33,null],[11,"drop","","",33,null],[11,"count","","",33,null],[11,"fill","","",33,null],[11,"revents","","",33,null],[11,"hash","","",31,null],[11,"cmp","","",31,null],[11,"partial_cmp","","",31,null],[11,"lt","","",31,null],[11,"le","","",31,null],[11,"gt","","",31,null],[11,"ge","","",31,null],[11,"eq","","",31,null],[11,"ne","","",31,null],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"to_db","","",31,null],[11,"from_db","","",31,{"inputs":[{"name":"f32"}],"output":{"name":"self"}}],[11,"deref","","",31,null],[11,"add","","",31,null],[11,"sub","","",31,null],[11,"fmt","","",34,null],[11,"clone","","",34,null],[11,"clone","","",35,null],[11,"next","","",35,null],[11,"new","","",36,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"selemid"}}],[11,"empty","","Returns an empty (zeroed) SelemId. This id is not a useable id and need to be initialized\nlike `SelemId::new()` does",36,{"inputs":[],"output":{"name":"selemid"}}],[11,"get_name","","",36,null],[11,"get_index","","",36,null],[11,"set_name","","",36,null],[11,"set_index","","",36,null],[11,"new","","Creates a Selem by wrapping `elem`.",37,{"inputs":[{"name":"elem"}],"output":{"name":"option"}}],[11,"register","","TODO: This function might change to support regopt and to return the mixer class",37,{"inputs":[{"name":"mixer"}],"output":{"name":"result"}}],[11,"get_id","","",37,null],[11,"has_capture_volume","","",37,null],[11,"has_capture_switch","","",37,null],[11,"has_playback_volume","","",37,null],[11,"has_playback_switch","","",37,null],[11,"can_capture","","",37,null],[11,"can_playback","","",37,null],[11,"has_volume","","",37,null],[11,"get_capture_volume_range","","returns range for capture volume as (min, max) values",37,null],[11,"get_capture_db_range","","returns (min, max) values.",37,null],[11,"get_playback_volume_range","","returns (min, max) values.",37,null],[11,"get_playback_db_range","","returns (min, max) values.",37,null],[11,"is_playback_mono","","",37,null],[11,"has_capture_channel","","",37,null],[11,"has_playback_channel","","",37,null],[11,"channel_name","","Gets name from snd_mixer_selem_channel_name",37,{"inputs":[{"name":"selemchannelid"}],"output":{"name":"result"}}],[11,"get_playback_volume","","",37,null],[11,"get_playback_vol_db","","returns volume in millibels.",37,null],[11,"ask_playback_vol_db","","Asks alsa to convert playback volume to millibels.",37,null],[11,"get_capture_volume","","",37,null],[11,"get_capture_vol_db","","returns volume in millibels.",37,null],[11,"ask_capture_vol_db","","Asks alsa to convert capture volume to millibels",37,null],[11,"set_playback_volume","","",37,null],[11,"set_playback_db","","",37,null],[11,"set_capture_db","","",37,null],[11,"set_playback_db_all","","",37,null],[11,"set_capture_db_all","","",37,null],[11,"set_capture_volume","","",37,null],[11,"set_playback_switch","","",37,null],[11,"set_playback_switch_all","","",37,null],[11,"set_capture_switch","","",37,null],[11,"set_capture_switch_all","","",37,null],[11,"get_playback_switch","","",37,null],[11,"get_capture_switch","","",37,null],[11,"is_enumerated","","",37,null],[11,"is_enum_playback","","",37,null],[11,"is_enum_capture","","",37,null],[11,"get_enum_items","","",37,null],[11,"get_enum_item_name","","",37,null],[11,"iter_enum","","Enumerates over valid Enum values",37,null],[11,"get_enum_item","","",37,null],[11,"set_enum_item","","",37,null],[11,"deref","","returns the elem of this selem",37,null],[11,"next","","",38,null],[11,"hash","","",32,null],[11,"cmp","","",32,null],[11,"partial_cmp","","",32,null],[11,"eq","","",32,null],[11,"clone","","",32,null],[11,"fmt","","",32,null],[11,"all","","Returns a slice of all possible values; useful for iteration",32,null],[11,"mono","","",32,{"inputs":[],"output":{"name":"selemchannelid"}}],[11,"fmt","","",32,null],[11,"drop","alsa","",39,null],[11,"buffer_open","","",39,{"inputs":[],"output":{"name":"result"}}],[11,"buffer_string","","",39,null],[11,"fmt","","",39,null],[11,"fmt","","",39,null],[11,"hash","alsa::pcm","",13,null],[11,"cmp","","",13,null],[11,"partial_cmp","","",13,null],[11,"eq","","",13,null],[11,"clone","","",13,null],[11,"fmt","","",13,null],[11,"all","","Returns a slice of all possible values; useful for iteration",13,null],[11,"hash","","",12,null],[11,"cmp","","",12,null],[11,"partial_cmp","","",12,null],[11,"eq","","",12,null],[11,"clone","","",12,null],[11,"fmt","","",12,null],[11,"all","","Returns a slice of all possible values; useful for iteration",12,null],[11,"fmt","","",12,null],[11,"drop","","",40,null],[11,"fmt","","",40,null],[11,"from","","",40,null],[11,"drop","","",41,null],[11,"next","","",41,null],[6,"Result","alsa","",null,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"eq","","",0,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"input","","",0,{"inputs":[],"output":{"name":"direction"}}],[11,"output","","",0,{"inputs":[],"output":{"name":"direction"}}],[11,"cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"eq","","",1,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"drop","alsa::ctl","",42,null],[11,"get_id","","",42,null],[11,"get_driver","","",42,null],[11,"get_components","","",42,null],[11,"get_longname","","",42,null],[11,"get_name","","",42,null],[11,"get_mixername","","",42,null],[11,"get_card","","",42,null],[11,"hash","","",7,null],[11,"cmp","","",7,null],[11,"partial_cmp","","",7,null],[11,"eq","","",7,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"all","","Returns a slice of all possible values; useful for iteration",7,null],[11,"hash","","",8,null],[11,"cmp","","",8,null],[11,"partial_cmp","","",8,null],[11,"eq","","",8,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"all","","Returns a slice of all possible values; useful for iteration",8,null],[11,"drop","","",43,null],[11,"get_boolean","","",43,null],[11,"set_boolean","","",43,null],[11,"get_integer","","",43,null],[11,"set_integer","","",43,null],[11,"get_integer64","","",43,null],[11,"set_integer64","","",43,null],[11,"get_enumerated","","",43,null],[11,"set_enumerated","","",43,null],[11,"get_byte","","",43,null],[11,"set_byte","","",43,null],[11,"get_bytes","","",43,null],[11,"set_bytes","","",43,null],[11,"fmt","","",43,null],[11,"drop","","",44,null],[11,"get_type","","",44,null],[11,"get_count","","",44,null],[11,"get_name","","",45,null],[11,"get_device","","",45,null],[11,"get_subdevice","","",45,null],[11,"get_numid","","",45,null],[11,"get_index","","",45,null],[11,"get_interface","","",45,null],[11,"fmt","","",45,null]],"paths":[[4,"Direction"],[4,"ValueOr"],[4,"Round"],[3,"Error"],[3,"Card"],[3,"Iter"],[3,"Ctl"],[4,"ElemIface"],[4,"ElemType"],[3,"HCtl"],[3,"ElemIter"],[3,"Elem"],[4,"ChmapPosition"],[4,"ChmapType"],[4,"State"],[4,"Format"],[4,"Access"],[3,"Info"],[3,"PCM"],[3,"IO"],[3,"HwParams"],[3,"SwParams"],[3,"Status"],[3,"Info"],[3,"Iter"],[3,"Rawmidi"],[3,"IO"],[3,"Hint"],[3,"HintIter"],[8,"PollDescriptors"],[3,"PollFlags"],[3,"MilliBel"],[4,"SelemChannelId"],[3,"Mixer"],[3,"Elem"],[3,"Iter"],[3,"SelemId"],[3,"Selem"],[3,"IterEnum"],[3,"Output"],[3,"Chmap"],[3,"ChmapsQuery"],[3,"CardInfo"],[3,"ElemValue"],[3,"ElemInfo"],[3,"ElemId"]]};
initSearch(searchIndex);
